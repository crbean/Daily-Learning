1:关联查询优化器-Mysql最重要的一部分就是关联查询优化
它决定了多个表关联时的顺序。
通常多表关联的时候，可以有多种不同的关联顺序来获得相同的执行结果。
关联查询优化器则通过评估不同顺序的成本来选择代价最小的那个。
2：straight join重写查询，优化器会根据自己手写的关联顺序来执行
3：排序优化
3.1：排序是一个成本很高的操作，从性能角度考虑，应尽可能避免排序或者尽可能避免对大量数据进行排序。
3.2：索引排序-->Mysql可以通过索引排序
3.3：文件排序-->当不能使用索引生成排序结果的时候，Mysql需要自己进行拍摄，如果数据量小则在内存中进行，如果数据量大则需要在磁盘中排序。
3.4：mysql排序算法
3.4.1：两次传输排序（旧版本使用）
读取行指针何需要排序的字段，对其进行排序，然后再根据排序结果读取所需要的数据行。
需要从数据表中读取两次数据，第二次读取数据的时候，因为时读取排序列进行排序后的所有记录，这回产生大量随机I/O，成本较高。
优点：在排序的时候存储尽可能少的数据，让“排序缓冲区”中尽可能容纳尽可能多的数据行进行排序。
3.4.2：单次传输排序（新版本使用）
先读取查询所需要的所有列，再根据给定列进行排序，最后直接返回排序结果。
优点：不需要从数据表读取两次数据，对于I/O密集型应用，会提高效率；这种算法只需要一次顺序I/O速度所有数据，而无需任何的随机I/O。
缺点：如果返回的数据列非常多，非常大，会额外占用大量的空间。
3.5：mysql在文件排序的所需临时存储空间将会非常大。对每个记录都会分配一个足够长的定长空间进行存放，这个定长空间必须足够长以容纳其中最长的字符串。
例如：如果是varchar列需要分配其最长长度，UTF-8字符集，mysql还将对每个字符预留三个字节。
3.6：关联查询两种排序方式
3.6.1：order by的所有列都来四关联的第一个表，mysql会在处理关联的第一个表的时候进行文件排序。explain using filesort；
3.6.2：除第一种情况外，mysql会将关联结果存放到一个临时表中，关联结束后在进行排序。explan using temporary；using filesort；
3.7：查询执行引擎
mysql的查询执行引擎会更加执行计划来完成整个查询。知识简单的根据执行计划给出的指令逐步执行。
3.8：返回结果给客户端
查询执行的最后一个阶段就是将结果返回客户端。
mysql将结果集返回客户端是一个增量，逐步返回的过程。服务器处理完最后一个关联表，开始生成第一条结果时，mysql姐可以开始向客户端逐步返回结果集了。
服务的无需存储过度结果，内存消耗低。
客户端可以第一时间获取返回的结果。