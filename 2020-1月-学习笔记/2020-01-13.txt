1:查询优化处理
查询的什么周期的下一步是将一个SQL转换成一个执行计划，MySQL再依照这个执行计划何存储引擎进行交互。包括：解析SQL、预处理、优化SQL执行计划
1.1：语法解析器何预处理
通过关键字将SQL预计进行解析，并生成一个对应的解析树
1.2：查询优化器
1.2.1：一条SQL可能有很多种执行方式，优化器的作用是找到这其中最好的执行计划
1.3：优化策略
1.3.1：静态优化 直接对解析树进行分析，并完成优化
1.2.3：动态优化 与查询的上下文有关，每次查询的时候都需要重新评估，运行时优化
1.4：MySQL能处理的优化类型
1.4.1：重新定义关联表的顺序 		--> 数据表的关联并不总是按照查询中指定的顺序进行。（没太理解）
1.4.2：将外连接转换成内连接 		--> 并不是所有的 OUTER JOIN 都必须以外连接的范式执行。（没太理解）
1.4.3：使用等价变换规则     		--> 可以合并何减少一些比较，还可以一处一些恒成立和恒不成立的条件判断。例如：(5=5 and a>5) ==> (a>5);( a<b and b=c ) and a= 5 ==> (b>5 and b=c and a=5)
1.4.4：优化 count()、min()、max() 	--> 存在索引的话只需要找到最左端记录就可以优化min()、最右端记录优化max();
1.4.5：预估并转化为常数表达式		--> MySQL检测到一个表达式可以转化成常数的时候，就会一直吧该表达式作为常数进行优化处理。例如：在索引列上执行min()。
1.4.6：覆盖索引扫描					--> 但索引的列包含所有查询中需要使用到的列的时候，MySQL就可以使用索引返回需要的数据，而无需查询对应的数据行。
1.4.7：子查询优化					--> 在某些特定情况下可以将子长县转换成一种效率更高的形式，从而检查多个查询多次对数据进行访问
1.4.8：提前终止查询					--> 发现已满足查询需求时，MySQL总能立刻终止查询。例如：limit
1.4.9：等值传播						-->  两个列的值通过等式关联，那么MySQL能够吧其中一个列的where条件传递到另一列上。例如：select film.fim_id from file inner join file_actor using(file_id) where film.file_id > 500 ==> where file.file_id > 500 and file_actor.id > 500
1.4.10：列表in()的比较				--> MySQL会将in()列表中的数据先进行排序，然后通过二分查找的范式来确定列表中的值是否满足条件。
